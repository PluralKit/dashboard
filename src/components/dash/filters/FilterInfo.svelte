<script lang="ts">
  import type { Group, Member } from "$api/types"
  import { dash, type DashList } from "$lib/dash/dash.svelte"
  import {
    FilterMode,
    filterFieldType,
    groupArrayModes,
    type Filter,
  } from "$lib/dash/filters.svelte"
  import Svelecte from "svelecte"

  let {
    filter,
    list,
  }: {
    filter: Filter
    list: DashList<Member | Group>
  } = $props()

  let filterValue = $state(filter.value)

  const changeValue = (e: Event) => {
    const target = e.target as HTMLInputElement
    filter.value = filter.valueType === "number" ? parseInt(target.value) : target.value
    list.process(dash.groups.list.raw)
    list.paginate()
  }
</script>

<!-- We need to handle groups and members separately again -->
{#if filter.field === "group" && groupArrayModes.includes(filter.mode)}
  <Svelecte
    class="svelecte-control-pk w-full"
    options={dash.groups.list.options}
    multiple
    valueField="value"
    labelField="text"
    bind:value={filterValue}
    onChange={() => {
      filter.value = $state.snapshot(filterValue)
      list.process(dash.groups.list.raw)
      list.paginate()
    }}
  />
{:else if filter.field === "member" && groupArrayModes.includes(filter.mode)}
  <Svelecte
    class="svelecte-control-pk w-full"
    options={dash.members.list.options}
    multiple
    valueField="value"
    labelField="text"
    bind:value={filterValue}
    onChange={() => {
      filter.value = $state.snapshot(filterValue)
      list.process(dash.groups.list.raw)
      list.paginate()
    }}
  />
{:else if filter.privacy}
  <select
    class="input input-sm input-bordered"
    onchange={(e) => {
      filter.value = (e.target as HTMLSelectElement)?.value
      list.process(dash.groups.list.raw)
      list.paginate()
    }}
    value={filter.value}
  >
    <option value="public">public</option>
    <option value="private">private</option>
  </select>
{:else if filter.proxy && filter.field === "proxy"}
  <Svelecte
    class="svelecte-control-pk w-full"
    options={dash.members.proxytags ? dash.members.proxytags : []}
    multiple
    bind:value={filter.proxy}
    valueField="value"
    labelField="text"
    onChange={() => {
      list.process(dash.groups.list.raw)
      list.paginate()
    }}
    option={proxyOption}
  />
{:else if filterFieldType(filter.field) === "date" && !(filter.mode === FilterMode.INCLUDES || filter.mode === FilterMode.EXCLUDES)}
  {#if filter.mode !== FilterMode.EMPTY && filter.mode !== FilterMode.NOTEMPTY}
    <input
      class="input input-sm input-bordered"
      type="date"
      value={filter.value}
      min={0}
      onchange={(e) => changeValue(e)}
    />
  {/if}
  <!-- The rest of the input types are either numbers or strings -->
{:else if filter.valueType === "number"}
  <input
    class="input input-sm input-bordered"
    placeholder={`Filter by ${filter.fieldName}...`}
    type="number"
    value={filter.value}
    min={0}
    onchange={(e) => changeValue(e)}
  />
{:else if filter.valueType === "string"}
  <input
    class="input input-sm input-bordered"
    placeholder={`Filter by ${filter.fieldName}...`}
    type="text"
    value={filter.value}
    onchange={(e) => changeValue(e)}
  />
{/if}

{#snippet proxyOption(opt: any)}
  <span
    >{opt.extra.prefix}<code class="px-0.5 bg-base-300 rounded-sm">text</code>{opt.extra
      .suffix}</span
  >
{/snippet}
